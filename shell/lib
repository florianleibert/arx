#!/bin/sh

# Note that shell variables are implicitly global. Thus, we require that all
# variables used in a function must be set in that function. Idempotent
# generators, like `tag', allow variables to be shared.

screen_S() {
  screen -S "`tag`" "$@"
}

# Initialize screen with settings. Settings are fed to screen's eval function,
# so each argument should be a string containg a whole setting, for example:
#
#   screen_setup 'zombie ko' 'defutf8 on'
#
screen_setup() {
  if [ ! -n "${screen_setup:-}" ]
  then
    tag="`tag`"
    ! { screen -ls | fgrep -q "$tag" ;} ||
      { echo 'ERR: screen collision!' 1>&2 ; return 2 ;}
    ( cd / ; screen_S -dm -ln sleep 2 ) # Ensure PWD for screen is /.
    screen_setup=true
    screen_S      -X eval 'screen 1 sleep 1' 'select 0' kill "$@"
  fi
}

# Launch command in initialized screen, after calling back in to this library
# to reset the working directory (since the screen is running in /).
screen_() {
  this_script="`canonical_path "$0"`"
  screen_setup
  screen_S      -X screen 0 "$this_script" cd_ "`pwd -P`" "$@"
  screen_S      -X eval 'select 1' kill
  echo "New screen is:" 1>&2
  echo "`tag`"
}


# Log to files o and e in the present directory.
files_oe() {
  "$@" 2>e 1>o
}

tee_oe() {
  general_redirect o e tee "$@"
}

syslog_oe() {
  general_redirect user.err user.info logger_shim "$@"
}

logger_shim() {
  tag="`tag`"
  logger -t "$tag" -i -p "$1"
}

# This redirect pattern is used for tee and logger.
general_redirect() {
  o="$1" ; e="$2" ; c="$3"
  shift  ; shift  ; shift
{   exec      3>&1 # Here, &1 refers to the grouping's STDOUT. We save it in &3.
  # In this line, &1 and &2 refer to the file descriptors of the command, not
  # of the grouping. We cause the STDERR reference to point to the new output
  # stream for this command, which is a pipe to the error logger, while we
  # cause the STDOUT reference to point to the output stream of the grouping
  # as a whole, which is a piped to the output logger.
    "$@"      2>&1 1>&3 |
  # Cause whatever output is produced by the error logger to go back on
  # STDERR. Tee will copy its input to STDOUT and logger can be made to copy
  # its input to STDERR; we handle both cases.
    "$c" "$e" 2>&2 1>&2
  # Cause whatever output is produced by the output logger to go back on
  # STDOUT, similar to the case for the error logger.
} | "$c" "$o" 2>&1 1>&1
}


# Portably determine a canonical path for the first argument. Intended to
# emulate `readlink --canonical' on systems that have a readlink which
# supports it.
canonical_path() {
  ( cd "`dirname "$1"`"
    d="`pwd -P`"
    echo "$d"/"`basename "$1"`"
  )
# LOLziness -- the canonical path of '.' is always '/a/b/c/.'
}


# Generates a tag for this process from the label and some random bytes.
# Subcommands that need a unique resource -- for example, a screen label --
# are very likely to get something unique this way; but they should always
# check it and fail if (by chance) another process has already taken it.
tag() {
  if [ ! -n "${tag:-}" ]
  then
    : ${label:=arx}
    tag="$label".`hexdump -n8 -e '"%08x-%08x"' < /dev/urandom`
  fi
  echo "$tag"
}


# Have to wrap cd so we can change the directory within the context of
# external calls to the script. For example,
#
#  ./lib cd_ <dir> files_oe
#
cd_() {
  cd "$1"
  shift
  "$@"
}

"$@"

